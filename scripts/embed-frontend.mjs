#!/usr/bin/env node
import { execSync } from "node:child_process";
import { readFileSync, readdirSync, statSync, writeFileSync } from "node:fs";
import { extname, join, relative, resolve } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = resolve(fileURLToPath(new URL(".", import.meta.url)));
const projectRoot = resolve(__dirname, "..");
const frontendRoot = resolve(projectRoot, "frontend");
const distDir = resolve(frontendRoot, "dist");
const outputFile = resolve(projectRoot, "src/frontend/assets.ts");

console.log("Building frontend with Viteâ€¦");
execSync("npx vite build --config frontend/vite.config.ts", {
  cwd: projectRoot,
  stdio: "inherit",
});

const assetFiles = new Map();

function collectAssets(directory) {
  for (const entry of readdirSync(directory)) {
    const fullPath = join(directory, entry);
    const info = statSync(fullPath);
    if (info.isDirectory()) {
      collectAssets(fullPath);
    } else {
      const relativePath = `/${relative(distDir, fullPath).replace(/\\/g, "/")}`;
      assetFiles.set(relativePath, fullPath);
    }
  }
}

collectAssets(distDir);

const BUILD_TIMESTAMP_PLACEHOLDER = "__BUILD_TIMESTAMP__";
const BUILD_TIMESTAMP = new Date().toISOString();
const TEXT_EXTENSIONS = new Set([
  ".css",
  ".html",
  ".js",
  ".json",
  ".map",
  ".svg",
  ".txt",
]);

function isTextFile(filePath) {
  const extension = extname(filePath).toLowerCase();
  return TEXT_EXTENSIONS.has(extension);
}

function replaceBuildTimestampPlaceholders() {
  for (const filePath of assetFiles.values()) {
    if (!isTextFile(filePath)) {
      continue;
    }

    const original = readFileSync(filePath, "utf8");
    if (!original.includes(BUILD_TIMESTAMP_PLACEHOLDER)) {
      continue;
    }

    const updated = original
      .split(BUILD_TIMESTAMP_PLACEHOLDER)
      .join(BUILD_TIMESTAMP);
    writeFileSync(filePath, updated);
  }
}

replaceBuildTimestampPlaceholders();

const indexHtmlPath = resolve(distDir, "index.html");
let html = readFileSync(indexHtmlPath, "utf8");

function readAsset(pathname) {
  const normalized = pathname.startsWith("/") ? pathname : `/${pathname}`;
  const filePath = assetFiles.get(normalized);
  if (!filePath) {
    throw new Error(`Unable to inline missing asset: ${pathname}`);
  }
  return readFileSync(filePath, "utf8");
}

function inlineStylesheets(document) {
  return document.replace(/<link[^>]*rel="stylesheet"[^>]*href="([^"]+)"[^>]*>/g, (_match, href) => {
    const css = readAsset(href);
    return `<style data-inline-href="${href}">\n${css}\n</style>`;
  });
}

function inlineScripts(document) {
  return document
    .replace(/<link[^>]*rel="modulepreload"[^>]*>/g, "")
    .replace(/<script([^>]*)src="([^"]+)"([^>]*)><\/script>/g, (_match, before, src, after) => {
      const js = readAsset(src);
      const typeAttr = /type="module"/.test(before + after)
        ? " type=\"module\""
        : "";
      return `<script${typeAttr}>\n${js}\n<\/script>`;
    });
}

html = inlineScripts(inlineStylesheets(html));
html = html.replace(/\s+$/g, "");

const banner = "// Auto-generated by scripts/embed-frontend.mjs. Do not edit by hand.\n";
const output = `${banner}export const FRONTEND_HTML = ${JSON.stringify(html)} as const;\n`;

writeFileSync(outputFile, output);
console.log(`Generated inline frontend at ${relative(projectRoot, outputFile)}`);
